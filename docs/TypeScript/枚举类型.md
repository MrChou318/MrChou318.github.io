---
title: 枚举类型
date: 2021-04-25 09:59:00 PM
categories:
    - TypeScript
tags:
    - TypeScript
---
## 一个角色判断的例子
```js
function initByRole(role) {
    if (role === 1 || role === 2) {
        // do sth
    } else if (role === 3 || role === 4) {
        // do sth
    } else if (role === 5) {
        // do sth
    } else {
        // do sth
    }
}
```
// 问题：1. 可读性差，很难记住数字的含义  
// 问题：2. 可维护性差：硬编码，牵一发动全身  
// 解决：可以使用ts的枚举类型

## 枚举类型
枚举：一组有名字的常量集合  
张三：13-xxxx-xxxx  
李四：18-xxxx-xxxx

### 数字枚举
```ts
enum Role {
    Reporter,
    Developer,
    Maintainer,
    Owner,
    Guest
}
```
枚举成员的值从0开始，依次递增，也可以自定义枚举成员的值
```ts
enum Role {
    Reporter = 1,
    Developer,
    Maintainer,
    Owner,
    Guest
}
```
枚举编译后实际上就是一个对象，我们既可以使用枚举成员的名字索引，也可以使用枚举成员的值进行索引，这是如何实现的呢？ 
我们来看看枚举编译后的结果：`tsc ./src/dataType.ts`
```js
var Role;
(function (Role) {
    Role[Role["Reporter"] = 0] = "Reporter";
    Role[Role["Developer"] = 1] = "Developer";
    Role[Role["Maintainer"] = 2] = "Maintainer";
    Role[Role["Owner"] = 3] = "Owner";
    Role[Role["Guest"] = 4] = "Guest";
})(Role || (Role = {}));
```
我们分析一下编译后的代码：
```js
let Role = {}
Role["Reporter"] = 0 // 枚举的成员名做为key，枚举成员的值作为了value， 返回枚举成员的值
Role[Role["Reporter"] = 0] = "Reporter" // 现在又是枚举成员的值作为key，枚举成为的名称作为value

// 这种方法就是反向映射，这就是枚举的实现原理
```
### 字符串枚举
```ts
enum Message {
    Success = '恭喜你，成功了',
    Fail = '抱歉，你失败了'
}
```
我们来看看字符串枚举的编译结果
```js
var Message;
(function (Message) {
    Message["Success"] = "\u606D\u559C\u4F60\uFF0C\u6210\u529F\u4E86";
    Message["Fail"] = "\u62B1\u6B49\uFF0C\u4F60\u5931\u8D25\u4E86";
})(Message || (Message = {}));
```
只有成员的名称作为了key，也就是说字符串枚举是不可以进行反向映射的

### 异构枚举
异构枚举：数字枚举和字符串枚举混用（容易引起混淆，不建议使用）
```ts
enum Answer {
    N,
    Y= 'Yes'
}
```

## 枚举成员的性质
### 枚举成员
#### 只读属性
```ts
enum Role {
    Reporter,
    Developer,
    Maintainer,
    Owner,
    Guest
}
Role.Reporter = 1   // 枚举成员的值是只读属性，定以后是不可以进行修改的
```
#### 枚举成员的分类
```ts
enum Char {
    // const 常量枚举，会在编译的时候计算出结果，然后以常量的形式出现在运行时环境
    a,  // 1. 没有初始值的情况
    b = Char.a, // 2. 对已有枚举成员的引用
    c = 1 + 3,  // 3. 一些常量的表达式
    // computed 需要被计算的枚举成员，枚举成员的值不会在编译阶段进行计算，而会保留到程序的执行阶段
    d = Math.random(),
    e = '123'.length
}
```
编译结果：
```js
var Char;
(function (Char) {
    // const 常量枚举，会在编译的时候计算出结果，然后以常量的形式出现在运行时环境
    Char[Char["a"] = 0] = "a";
    Char[Char["b"] = 0] = "b";
    Char[Char["c"] = 4] = "c";
    // computed 需要被计算的枚举成员，枚举成员的值不会在编译阶段进行计算，而会保留到程序的执行阶段
    Char[Char["d"] = Math.random()] = "d";
    Char[Char["e"] = '123'.length] = "e";
})(Char || (Char = {}));
```
需要注意的是：在computed后面的枚举成员一定要赋予初始值
```ts
enum Char {
    // const 常量枚举，会在编译的时候计算出结果，然后以常量的形式出现在运行时环境
    a,  // 1. 没有初始值的情况
    b = Char.a, // 2. 对已有枚举成员的引用
    c = 1 + 3,  // 3. 一些常量的表达式
    // computed 需要被计算的枚举成员，枚举成员的值不会在编译阶段进行计算，而会保留到程序的执行阶段
    d = Math.random(),
    e = '123'.length,
    f = 1
}
```
### 常量枚举
常量枚举：用const声明的枚举就是常量枚举
```ts
const enum Month {
    Jan,
    Feb,
    Mar
}
```
常量枚举会在编译阶段被移除（编译后没有任何代码）；  
那它作用是什么呢：当我们不需要一个对象，而需要对象的值的时候，就可以使用常量枚举，这样可以减少我们在编译环境的代码。
```ts
const enum Month {
    Jan,
    Feb,
    Mar
}
let month = [Month.Jan, Month.Feb]
```
编译后：
```js
var month = [0 /* Jan */, 1 /* Feb */];
```
// 枚举类型
在某些情况下，枚举和枚举成员都可以作为一种单独的类型存在
```ts
enum E {
    a,
    b
}
enum F {
    a = 0,
    b = 1
}
enum G {
    a = 'apple',
    b = 'banana'
}
let e: E = 3    // 我们可以把number类型赋值给枚举类型，取值也可以超出枚举成员的定义
let f: F = 3
e === f // 两种不同类型的枚举是不可以进行比较的

let e1: E.a = 1
let e2: E.b = 2
let e3: E.a = 3
e1 === e2   // e1和e2是永远不可以进行比较的，
e1 === e3   // e1和e3是相同的枚举成员类型，就可以进行比较

let g1: G = G.a   // 字符串枚举的取值只能是枚举成员的类型
let g2: G.a = G.a
```

代码改造：
```ts
enum RoleEnum {
    Reporter = 1,
    Developer,
    Maintainer,
    Owner,
    Guest
}
function initRole(role: RoleEnum) {
    if (role === RoleEnum.Reporter || role === RoleEnum.Developer) {
        // do sth
    } else if (role === RoleEnum.Maintainer || role === RoleEnum.Owner) {
        // do sth
    } else if (role === RoleEnum.Guest) {
        // do sth
    } else {
        // do sth
    }
}
```
